use std::str::FromStr;

use ed25519_dalek::Verifier;

pub struct Signature(pub(crate) ed25519_dalek::Signature);

impl Signature {
    /// Creates a [`Signature`] from the given bytes.
    #[inline]
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ed25519_dalek::SignatureError> {
        Ok(Self(bytes.try_into()?))
    }

    /// Constructs a [`Signature`] from a hexadecimal string slice.
    ///
    /// ## Notes
    /// - The string must either include all uppercase or all lowercase
    ///   hexadecimal letters.
    #[inline]
    pub fn from_hex(hex: &str) -> Result<Self, ed25519_dalek::SignatureError> {
        Ok(Self(hex.parse()?))
    }

    /// Lends the bytes of the signature out.
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_ref()
    }

    /// Converts the given signature to a hex [`String`].  
    #[inline]
    pub fn as_hex(&self) -> String {
        hex::encode(self.as_bytes())
    }
}

impl TryFrom<&str> for Signature {
    type Error = ed25519_dalek::SignatureError;
    #[inline]
    fn try_from(hex: &str) -> Result<Self, Self::Error> {
        Self::from_hex(hex)
    }
}

impl TryFrom<&[u8]> for Signature {
    type Error = ed25519_dalek::SignatureError;
    #[inline]
    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        Self::from_bytes(bytes)
    }
}

impl AsRef<[u8]> for Signature {
    #[inline]
    fn as_ref(&self) -> &[u8] {
        self.as_bytes()
    }
}

impl FromStr for Signature {
    type Err = ed25519_dalek::SignatureError;
    #[inline]
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        ed25519_dalek::Signature::from_str(s).map(|s| Self(s))
    }
}

/// Verifies if the message's signature was generated by the account with the
/// provided public key.
#[inline]
pub fn verify_signature<PK: AsRef<[u8]>, Msg: AsRef<[u8]>>(
    public_key: PK,
    message: Msg,
    signature: Signature,
) -> Result<(), ed25519_dalek::SignatureError> {
    let public_key = public_key.as_ref();
    let message = message.as_ref();
    let public_key = ed25519_dalek::PublicKey::from_bytes(public_key)?;
    public_key.verify(message, &signature.0)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn verifying_signatures() {
        let sig = hex::decode("dea6ad327c3a6e2cd3e96144f2b5f88a8f272d8849ec9898cd44cded6e54e72bf7c8d8a23e316c089da4b24b81e6958d7461c01902b03c64525054a73ccc1b0f").unwrap();
        verify_signature(
            &hex::decode("0fa2596d9fada397a6668463fed71c8c7260a411d108da6480d65121d443cc58")
                .unwrap(),
            "asdfasdfasdfasdfasdfasdfasdfasdfasdf",
            Signature::from_bytes(&sig).unwrap(),
        )
        .unwrap();
    }
}
